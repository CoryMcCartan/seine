% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ei_local.R
\name{ei_est_local}
\alias{ei_est_local}
\alias{as.array.ei_est_local}
\title{Produce local ecological estimates}
\usage{
ei_est_local(
  regr,
  data,
  total,
  b_cov = NULL,
  contrast = NULL,
  bounds = regr$blueprint$bounds,
  sum_one = NULL,
  conf_level = 0.95,
  regr_var = TRUE,
  unimodal = TRUE
)

\method{as.array}{ei_est_local}(x, ...)
}
\arguments{
\item{regr}{A fitted regression model, from \code{\link[=ei_ridge]{ei_ridge()}}, or another kind
of regression model wrapped with \code{\link[=ei_wrap_model]{ei_wrap_model()}}.}

\item{data}{The data frame, matrix, or \link{ei_spec} object that was used to fit
the regression.}

\item{total}{<\code{\link[tidyselect:language]{tidy-select}}> A variable
containing the total number of observations in each aggregate unit. For
example, the column containing the total number of voters. Required if
\code{data} is not an \code{\link[=ei_spec]{ei_spec()}} object.}

\item{b_cov}{A covariance matrix to use in projecting the
local estimates onto the accounting constraint, such as one estimated with
\code{\link[=ei_local_cov]{ei_local_cov()}}. Defaults to the identity matrix scaled by the residual
variance of \code{regr}, corresponding to orthogonal projection.
Set \code{b_cov=1} to use a degenerate covariance matrix corresponding to a
(local) neighborhood model. When there are multiple outcome variables and
\code{b_cov} is a matrix with entries for each predictor, it will be applied
identically to each outcome. Alternatively, a matrix with entries for each
predictor-outcome combination may be provided, with entries in the order
(Y1|X1, Y1|X2, ..., Y2|X1, Y2|X2, ...).}

\item{contrast}{If provided, a list containing entries \code{predictor} and
\code{outcome}, each containing a contrast vector.  If only one of \code{predictor}
or \code{outcome} is provided, the contrast will be calculated for all levels of
the other variable.  For example \code{list(predictor = c(1, -1, 0))} will
calculate the difference in each outcome between the first and second
predictor groups; \code{list(outcome = c(1, -1))} will calculate the difference
between the two outcomes for each predictor group; and
\code{list(predictor = c(1, -1, 0), outcome = c(1, -1))} will calculate the
difference in differences.}

\item{bounds}{A vector \code{c(min, max)} of bounds for the outcome, to which the
local estimates will be truncated. In general, truncation will lead to
violations of the accounting identity. If \code{bounds = NULL}, they will be
inferred from the outcome variable: if it is contained within \eqn{[0, 1]},
for instance, then the bounds will be \code{c(0, 1)}. Setting \code{bounds = FALSE}
forces unbounded estimates. The default uses the \code{bounds} attribute of
\code{regr}, if available, or infers from the outcome variable otherwise.
Note that bounds are currently not applied if \code{contrast} is provided.}

\item{sum_one}{If \code{TRUE}, the outcome variables are constrained to sum to one.
Can only apply when \code{bounds} are enforced and there is more than one
outcome variable. If \code{NULL}, infers \code{sum_one = TRUE} when the bounds
are \code{c(0, 1)} the outcome variables sum to 1.}

\item{conf_level}{A numeric specifying the level for confidence intervals.
If \code{FALSE}, no confidence intervals are calculated.
For \code{regr} arguments from \code{\link[=ei_wrap_model]{ei_wrap_model()}}, confidence intervals will not
incorporate uncertainty in the prediction itself, just the residual. This
will trigger a warning periodically.}

\item{regr_var}{If \code{TRUE}, incorporate uncertainty from the regression model
when calculating confidence intervals. Only applies when \code{regr} is fitted
with \code{\link[=ei_ridge]{ei_ridge()}}, and requires that function be called with \code{vcov = TRUE}.}

\item{unimodal}{If \code{TRUE}, assume a unimodal residual distribution. Reduces
width of confidence intervals by a factor of 2/3.}

\item{x}{An object of class \code{ei_est_local}}

\item{...}{Additional arguments (ignored)}
}
\value{
A data frame with estimates. The \code{.row} column in the output
corresponds to the observation index in the input. The \code{weight} column contains
the product of the predictor variable and total for each observation.
Taking a weighted average of the estimate against this column will produce
a global estimate. It has class \code{ei_est_local}.
}
\description{
Projects predictions from a fitted regression model onto the accounting
constraint using a provided residual covariance matrix. This ensures that
each set of local estimates satisfies the accounting identity. Local
estimates may be truncated to variable bounds.
}
\details{
Local estimates are produced jointly across outcome variables. When bounds
are applied, unless \code{sum_one = TRUE}, the estimates for each observation may
not satisfy logical constraints, including the accounting identity.

Projections are done obliquely in accordance with \code{b_cov} via quadratic
programming. Occasionally, the quadratic program may be infeasible due to
the specific data, features of \code{b_cov}, or numerical errors. Various
relaxations of the accounting identity and \code{b_cov} are attempted in these cases;
indices where relaxations of \code{b_cov} were used are stored in the \code{proj_relax}
attribute of the output, and indices of infeasible projections are stored in
the \code{proj_misses} attribute.
}
\section{Methods (by generic)}{
\itemize{
\item \code{as.array(ei_est_local)}: Format estimates an array with dimensions
\verb{<rows>*<predictors>*<outcomes>}. Does not work if the object has been sorted.

}}
\examples{
data(elec_1968)

spec = ei_spec(elec_1968, vap_white:vap_other, pres_dem_hum:pres_abs,
               total = pres_total, covariates = c(state, pop_urban, farm))

m = ei_ridge(spec)

ei_est_local(m, spec, bounds = c(0, 1), sum_one = TRUE, conf_level = 0.99)

b_cov = ei_local_cov(m, spec)
e_orth = ei_est_local(m, spec, bounds = c(0, 1), sum_one = TRUE)
e_nbhd = ei_est_local(m, spec, b_cov = 1, bounds = c(0, 1), sum_one = TRUE)
e_rcov = ei_est_local(m, spec, b_cov = b_cov, bounds = c(0, 1), sum_one = TRUE)
# average interval width
c(
    e_orth = mean(e_orth$conf.high - e_orth$conf.low),
    e_nbhd = mean(e_nbhd$conf.high - e_nbhd$conf.low),
    e_rcov = mean(e_rcov$conf.high - e_rcov$conf.low)
)
}
\references{
McCartan, C., & Kuriwaki, S. (2025+). Identification and semiparametric
estimation of conditional means from aggregate data.
Working paper \href{https://arxiv.org/abs/2509.20194}{arXiv:2509.20194}.
}
