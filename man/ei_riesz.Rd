% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ei_riesz.R
\name{ei_riesz}
\alias{ei_riesz}
\alias{ei_riesz.formula}
\alias{ei_riesz.ei_spec}
\alias{ei_riesz.data.frame}
\alias{ei_riesz.matrix}
\alias{ei_riesz.default}
\title{Estimate Riesz representer for ecological inference}
\usage{
ei_riesz(x, ..., weights, penalty, bounds = FALSE, y = NULL, scale = TRUE)

\method{ei_riesz}{formula}(
  formula,
  data,
  total,
  weights,
  penalty,
  bounds = FALSE,
  y = NULL,
  scale = TRUE,
  ...
)

\method{ei_riesz}{ei_spec}(x, weights, penalty, bounds = FALSE, y = NULL, scale = TRUE, ...)

\method{ei_riesz}{data.frame}(
  x,
  z,
  total,
  weights,
  penalty,
  bounds = FALSE,
  y = NULL,
  scale = TRUE,
  ...
)

\method{ei_riesz}{matrix}(
  x,
  z,
  total,
  weights,
  penalty,
  bounds = FALSE,
  y = NULL,
  scale = TRUE,
  ...
)

\method{ei_riesz}{default}(x, ..., weights, penalty, bounds = FALSE, y = NULL, scale = TRUE)
}
\arguments{
\item{x}{Depending on the context:
\itemize{
\item A \strong{data frame} of predictors.
\item A \strong{matrix} of predictors.
\item An \link{ei_spec} object containing the outcome, predictor, and covariates.
}

Predictors must be proportions that sum to 1 across rows.
You can use \code{\link[=ei_proportions]{ei_proportions()}} to assist in preparing predictor variables.
Covariates in an \link{ei_spec} object are shifted to have mean zero. If
\code{scale=TRUE} (the default), they are also scaled to have unit variance.}

\item{...}{Not currently used, but required for extensibility.}

\item{weights}{<\code{\link[rlang:args_data_masking]{data-masking}}> A vector of unit
weights for estimation. These may be the same or different from the total
number of observations in each aggregate unit (see the \code{total} argument to
\code{\link[=ei_spec]{ei_spec()}}). See the discussion below under 'Weights' for choosing this
parameter. The default, uniform weights, makes a slightly
stronger-than-necessary assumption about the relationship between the
unit totals and the unknown data.}

\item{penalty}{The ridge penalty (a non-negative scalar), which must be
specified. Recommended value is the same penalty used in \code{\link[=ei_ridge]{ei_ridge()}},
which is stored in the \code{penalty} entry of the fitted model object.}

\item{bounds}{A vector \code{c(min, max)} of bounds for the outcome.
If \code{bounds = NULL}, they will be inferred from the outcome variable:
if it is contained within \eqn{[0, 1]}, for instance, then the bounds will
be \code{c(0, 1)}. The default \code{bounds = FALSE} uses an unbounded outcome.}

\item{y}{When \code{x} is a \strong{data frame} or \strong{matrix}, \code{y} is the outcome
specified as:
\itemize{
\item A \strong{data frame} with numeric columns.
\item A \strong{matrix}
\item A numeric \strong{vector}.
}

When the outcome is a proportion, you can use \code{\link[=ei_proportions]{ei_proportions()}} to assist
in preparing it.}

\item{scale}{If \code{TRUE}, scale covariates \code{z} to have unit variance.}

\item{formula}{A formula such as \code{y ~ x0 + x1 | z} specifying the outcome \code{y}
regressed on the predictors of interest \code{x} and any covariates \code{z}.
The predictors should form a partition, that is, \code{x0 + x1 = 1} for each
observation. Users can be include more than two predictors as well, e.g.
\code{pct_white + pct_black + pct_hisp + pct_other}.
If there are just two predictors, it is acceptable to only include one in
the formula; the other will be formed as 1 minus the provided predictor.
Include additional covariates separated by a vertical bar \code{|}.
These covariates are strongly recommended for reliable ecological inference.
Covariates are shifted to have mean zero. If \code{scale=TRUE} (the default),
they are also scaled to have unit variance.}

\item{data}{When a \strong{formula} is used, \code{data} is a \strong{data frame} containing
both the predictors and the outcome.}

\item{total}{<\code{\link[rlang:args_data_masking]{data-masking}}> A variable
containing the total number of observations in each aggregate unit. For
example, the column containing the total number of voters. Required by
default.}

\item{z}{When \code{x} is a \strong{data frame} or \strong{matrix}, \code{w} are any covariates,
specified as:
\itemize{
\item A \strong{data frame} with numeric columns.
\item A \strong{matrix}
}

These are shifted to have mean zero. If \code{scale=TRUE} (the default), they
are also scaled to have unit variance.}
}
\value{
An \code{ei_riesz} object.
}
\description{
Fits a penalized Riesz regression for ecological inference, allowing for
overall estimates of conditional means using \code{\link[=ei_est]{ei_est()}}.
}
\details{
The regression is calculated using the singular value decomposition.
}
\section{Weights}{

The weakest identification result for ecological inference makes no
assumption about the number of observations per aggregate unit (the totals).
It requires, however, weighting the estimation steps according to the totals.
This may reduce efficiency when the totals are variable and a slightly
stronger condition holds.

Specifically, if the totals are conditionally mean-independent of the missing
data (the aggregation-unit level means of the outcome within each predictor
level), given covariates, then it is appropriate to use uniform weights in
estimation, or any fixed set of weights.

In general, estimation efficiency is improved when units with larger variance
in the outcome receive less weight. Various bulit-in options are provided by
the helper functions in \code{\link[=ei_wgt]{ei_wgt()}}.
}

\examples{
data(elec_1968)

# Recommended: get ridge penalty from ei_ridge()
spec = ei_spec(elec_1968, vap_white:vap_other, pres_dem_hum:pres_abs,
               total = pres_total, covariates = c(pop_urban, farm))
m = ei_ridge(spec)

ei_riesz(spec, penalty = m$penalty)

rr = ei_riesz(~ vap_white + vap_black + vap_other | pop_urban + farm,
              data = elec_1968, total = pres_total, penalty = m$penalty)
summary(rr)

# Examine the weights and check they have mean 1
head(weights(rr, group = "vap_black"))
colMeans(weights(rr))

mean(elec_1968$pres_ind_wal * weights(rr, "vap_white"))
}
