% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ei_bounds.R
\name{ei_bounds}
\alias{ei_bounds}
\alias{ei_bounds.ei_spec}
\alias{ei_bounds.formula}
\alias{ei_bounds.data.frame}
\alias{ei_bounds.matrix}
\alias{ei_bounds.default}
\alias{as.array.ei_bounds}
\title{Compute bounds on local ecological quantities}
\usage{
ei_bounds(x, ..., total, contrast = NULL, bounds = c(0, 1), global = FALSE)

\method{ei_bounds}{ei_spec}(x, total, contrast = NULL, bounds = c(0, 1), global = FALSE, ...)

\method{ei_bounds}{formula}(
  formula,
  data,
  total,
  contrast = NULL,
  bounds = c(0, 1),
  global = FALSE,
  ...
)

\method{ei_bounds}{data.frame}(x, y, total, contrast = NULL, bounds = c(0, 1), global = FALSE, ...)

\method{ei_bounds}{matrix}(x, y, total, contrast = NULL, bounds = c(0, 1), global = FALSE, ...)

\method{ei_bounds}{default}(x, ...)

\method{as.array}{ei_bounds}(x, ...)
}
\arguments{
\item{x}{An object of class \code{ei_bounds}}

\item{...}{Additional arguments (ignored)}

\item{total}{<\code{\link[rlang:args_data_masking]{data-masking}}> A variable
containing the total number of observations in each aggregate unit. For
example, the column containing the total number of voters. Required for
computing weights unless \code{x} is an \code{\link[=ei_spec]{ei_spec()}} object.}

\item{contrast}{If provided, a list containing entries \code{predictor} and
\code{outcome}, each containing a contrast vector.  If only one of \code{predictor}
or \code{outcome} is provided, the contrast will be calculated for all levels of
the other variable.  For example \code{list(predictor = c(1, -1, 0))} will
calculate the difference in each outcome between the first and second
predictor groups; \code{list(outcome = c(1, -1))} will calculate the difference
between the two outcomes for each predictor group; and
\code{list(predictor = c(1, -1, 0), outcome = c(1, -1))} will calculate the
difference in differences.}

\item{bounds}{A vector \code{c(min, max)} of bounds for the outcome.
If \code{bounds = NULL}, they will be inferred from the outcome variable:
if it is contained within \eqn{[0, 1]}, for instance, then the bounds will
be \code{c(0, 1)}. The default \code{bounds = FALSE} uses an unbounded outcome.}

\item{global}{If \code{TRUE}, aggregate the bounds across units to produce bounds
on the global estimands.}

\item{formula}{A formula such as \code{y ~ x0 + x1} specifying the outcome \code{y}
and the predictors of interest \code{x}. The predictors should form a partition,
that is, \code{x0 + x1 = 1} for each observation.
Users can be include more than two predictors as well, e.g.
\code{pct_white + pct_black + pct_hisp + pct_other}.
If there are just two predictors, it is acceptable to only include one in
the formula; the other will be formed as 1 minus the provided predictor.}

\item{data}{When a \strong{formula} is used, \code{data} is a \strong{data frame} containing
both the predictors and the outcome.}

\item{y}{When \code{x} is a \strong{data frame} or \strong{matrix}, \code{y} is the outcome
specified as:
\itemize{
\item A \strong{data frame} with numeric columns.
\item A \strong{matrix}
\item A numeric \strong{vector}.
}

When the outcome is a proportion, you can use \code{\link[=ei_proportions]{ei_proportions()}} to assist
in preparing it.}
}
\value{
A data frame with bounds. The \code{.row} column in the output
corresponds to the observation index in the input. The \code{min} and \code{max}
columns contain the minimum and maximum values for each local estimand.
The \code{wt} column contains the product of the predictor variable and total
for each observation. Taking a weighted average of the bounds against this
column will produce global bounds. It has class \code{ei_bounds}.
}
\description{
For each observation, computes the minimum and maximum value of each local
estimand that is consistent with the accounting constraint \eqn{B \%*\% x = y},
where \eqn{B} is the matrix of local estimands, \eqn{x} are the predictors,
and \eqn{y} are the outcomes.
}
\section{Methods (by generic)}{
\itemize{
\item \code{as.array(ei_bounds)}: Format bounds as an array with dimensions
\verb{<rows>*<predictors>*<outcomes>*2}. Does not work if the object has been sorted.

}}
\examples{
data(elec_1968)

spec = ei_spec(elec_1968, vap_white:vap_other, pres_dem_hum:pres_abs,
               total = pres_total, covariates = c(state, pop_urban, farm))

ei_bounds(spec, bounds = c(0, 1))
ei_bounds(spec, bounds = c(0, 1), global = TRUE)

# Infer bounds
ei_bounds(pres_ind_wal ~ vap_white, data = elec_1968, total = pres_total, bounds = NULL)

# manually aggregate min/max
# easier with dplyr:
# summarize(across(min:max, ~ weighted.mean(.x, wt)), .by=c(predictor, outcome))
grp_units = split(ei_bounds(spec, bounds = c(0, 1)), ~ predictor + outcome)
do.call(rbind, lapply(grp_units, function(b) {
    tibble::tibble(
        predictor = b$predictor[1],
        outcome = b$outcome[1],
        min = weighted.mean(b$min, b$wt),
        max = weighted.mean(b$max, b$wt)
    )
}))

}
